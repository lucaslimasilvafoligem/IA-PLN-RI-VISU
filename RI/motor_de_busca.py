# -*- coding: utf-8 -*-
"""LAB4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UM07tyqZergvHXp457lS3edwbyDDY3iv

**Alunos:**

João Pedro Campos Porto
Lucas de Lima da Silva
Levi de Lima Pereira Júnior

# In-Memory Search Engine

Hoje vamos implementar um pequeno motor de busca para exercitar os principais conceitos vistos na disciplina até o momento.

Após a submissão de todas as soluções, iremos discutir/avaliar/comparar as implementações enviadas pelos grupos.

Durante a aula de discussão, os membros do grupo serão questionados sobre os detalhes da implementação. A pergunta poderá ser direcionada para um membro específico, sem que os demais possam ajudar a responder.

**INSTRUÇÕES**

Esta atividade deve ser feita em grupos de 3 alunos. Apenas 1 aluno precisa enviar pelo classroom. Não esqueçam de informar os nomes dos membros.

Além do envio pelo classroom, haverá um formulário para envio do link (basta 1 aluno preencher).

Cuidado: verifique se a opção de compartilhamento está no formato "todos com o link podem acessar". Caso não esteja compartilhado corretamente, a submissão será ignorada. ATENÇÃO: a última edição do arquivo deve ser antes do prazo de entrega.

**DESCRIÇÃO**

O motor de busca deverá ser capaz de ler os dados de um arquivo CSV com 2 colunas:

* id: o ID do documento (número inteiro sequencial)
* text: o texto do documento

Como a intenção é fazer um motor de busca bem simples, o índice invertido é mantido 100% em memória, na estrutura que julgarem mais adequada. Também não iremos nos preocupar com compressão de índice para economizar memória.

Os textos dos documentos devem passar por um pré-processamento antes de serem indexados.

A estratégia ranqueamento pode ser baseada em TF/IDF ou alguma estratégia simples.

O buscador **não** precisa fazer busca tolerante.

Há uma classe python pré-definida que deve existir, onde você deve criar os métodos. Porém, se quiser criar outras classes para serem usadas pela classe principal, não há problema.

Considerem que o buscador vai processar textos em **inglês**!

Bom trabalho!

# Implementação
"""

!pip install pandas
!pip install nltk

"""## Classe Principal do Buscador"""

import pandas as pd
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from math import log
from nltk.tokenize import RegexpTokenizer
import nltk
nltk.download('punkt')
nltk.download('stopwords')

class InMemSearchEngine():

    def __init__(self, path_corpus_file):
        self.indice_invertido = {}
        self.processados_documentos = {}
        self.ler_documentos_e_processar(path_corpus_file)
        self.construir_indice_invertido()
    def ler_documentos_e_processar(self, arquivo_csv):
        if(arquivo_csv is not None):
          data = pd.read_csv(arquivo_csv)
        for index, row in data.iterrows():
          if(row['text'] is not None):
            doc_id = int(row['id'])
            texto = row['text']
            tokens = self.processar_texto(texto)
            self.processados_documentos[doc_id] = tokens

    def construir_indice_invertido(self):
        for doc_id, tokens in self.processados_documentos.items():
            for token in set(tokens):
                if token not in self.indice_invertido:
                    self.indice_invertido[token] = set()
                self.indice_invertido[token].add(doc_id)

    def processar_texto(self, texto):
        stop_words = set(stopwords.words("english"))
        tokens = word_tokenize(texto.lower())
        tokenizer = RegexpTokenizer(r'\w+')
        texto_sem_stopwords = [token for token in tokens if token not in stop_words]
        return texto_sem_stopwords

    def calcular_tf_idf_bm25(self, query, doc_id, k=1.5, b=0.75):
        score = 0
        avgdl = sum(len(doc) for _, doc in self.processados_documentos.items()) / len(self.processados_documentos)
        doc_tokens = self.processados_documentos[doc_id]
        doc_length = len(doc_tokens)
        query_tokens = set(self.processar_texto(query.lower()))
        for token in query_tokens:
            if token in self.indice_invertido:
                tf = doc_tokens.count(token)
                idf = log((len(self.processados_documentos) - len(self.indice_invertido[token]) + 0.5) / (len(self.indice_invertido[token]) + 0.5) + 1)
                score += idf * (tf * (k + 1)) / (tf + k * (1 - b + b * doc_length / avgdl))
        return score

    def search(self, query):
        scores = {}
        for doc_id, doc_tokens in self.processados_documentos.items():
            scores[doc_id] = self.calcular_tf_idf_bm25(query, doc_id)
        resultados = sorted(scores.items(), key=lambda x: x[1], reverse=True)
        return resultados
    def organizaOutPut(self,resultados):
      response = []
      for a in range(len(results)):
        if(results[a][1] != 0):
          response.append(results[a])
      return response

"""## Exemplo de código mostrando como a classe vai ser usada nos testes"""

path_corpus_file = '/content/sample_data/docs.csv'

se = InMemSearchEngine(path_corpus_file)

query = 'Social and ethical implications of data in politics'

results = se.search(query)
response = se.organizaOutPut(results)

print(response)
